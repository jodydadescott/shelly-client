package types

import (
	"fmt"

	"github.com/jinzhu/copier"
)

// Auth RFC7616 HTTP Digest Access Authentication
// https://www.rfc-editor.org/rfc/rfc7616
type AuthResponse struct {
	// realm: string, device_id of the Shelly device. Required
	Realm string `json:"realm" yaml:"realm"`
	// username: string, must be set to admin. Required
	Username string `json:"username" yaml:"username"`
	// nonce: number, random or pseudo-random number to prevent replay attacks, taken from the error message. Required
	Nonce string `json:"nonce" yaml:"nonce"`
	// cnonce: number, client nonce, random number generated by the client. Required
	Cnonce string `json:"cnonce" yaml:"cnonce"`
	// response: string, encoding of the string <ha1> + ":" + <nonce> + ":" + <nc> + ":" + <cnonce> + ":" + "auth" + ":" + <ha2> in SHA256. Required
	// ha1: string, <user>:<realm>:<password> encoded in SHA256
	// ha2: string, "dummy_method:dummy_uri" encoded in SHA256
	Response string `json:"response" yaml:"response"`
	// algorithm: string, SHA-256. Required
	Algorithm string `json:"algorithm" yaml:"algorithm"`
}

type AuthRequest struct {
	AuthType   string `json:"auth_type" yaml:"auth_type"`
	Nonce      int    `json:"nonce" yaml:"nonce"`
	NonceCount int    `json:"nc" yaml:"nc"`
	Realm      string `json:"realm" yaml:"realm"`
	Algorithm  string `json:"algorithm" yaml:"algorithm"`
	Username   string `json:"username" yaml:"username"`
	Password   string `json:"password" yaml:"password"`
}

// Clone return copy
func (t *AuthRequest) Clone() *AuthRequest {
	c := &AuthRequest{}
	copier.Copy(&c, &t)
	return c
}

func (t *AuthRequest) ToAuthResponse() (*AuthResponse, error) {

	if t.NonceCount <= 0 {
		return nil, fmt.Errorf("attribute 'NonceCount' not valid")
	}

	if t.Realm == "" {
		return nil, fmt.Errorf("attribute 'Realm' empty")
	}

	if t.Algorithm == "" {
		return nil, fmt.Errorf("attribute 'Algorithm' empty")
	}

	if t.Username == "" {
		return nil, fmt.Errorf("attribute 'Username' empty")
	}

	if t.Password == "" {
		return nil, fmt.Errorf("attribute 'Password' empty")
	}

	cnonce := getCnonce()

	auth := &AuthResponse{
		Nonce:     fmt.Sprintf("%d", t.Nonce),
		Realm:     t.Realm,
		Username:  t.Username,
		Cnonce:    cnonce,
		Algorithm: t.Algorithm,
	}

	switch t.Algorithm {

	case "SHA-256":
		ha1 := getSHA256(t.Username + ":" + t.Realm + ":" + t.Password)
		// ha2 := getSHA256("dummy_method:dummy_uri")
		auth.Response = getSHA256(fmt.Sprintf("%s:%d:%v:%s:%s:%s", ha1, t.Nonce, t.NonceCount, cnonce, "auth", dummyHA2))

	default:
		return nil, fmt.Errorf("algorithm %s not supported", auth.Algorithm)

	}

	return auth, nil
}
