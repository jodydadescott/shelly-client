package types

import (
	"context"
	"fmt"

	"github.com/jinzhu/copier"
)

// Auth RFC7616 HTTP Digest Access Authentication
// https://www.rfc-editor.org/rfc/rfc7616
type AuthResponse struct {
	// realm: string, device_id of the Shelly device. Required
	Realm string `json:"realm" yaml:"realm"`
	// username: string, must be set to admin. Required
	Username string `json:"username" yaml:"username"`
	// nonce: number, random or pseudo-random number to prevent replay attacks, taken from the error message. Required
	Nonce string `json:"nonce" yaml:"nonce"`
	// cnonce: number, client nonce, random number generated by the client. Required
	Cnonce string `json:"cnonce" yaml:"cnonce"`
	// response: string, encoding of the string <ha1> + ":" + <nonce> + ":" + <nc> + ":" + <cnonce> + ":" + "auth" + ":" + <ha2> in SHA256. Required
	// ha1: string, <user>:<realm>:<password> encoded in SHA256
	// ha2: string, "dummy_method:dummy_uri" encoded in SHA256
	Response string `json:"response" yaml:"response"`
	// algorithm: string, SHA-256. Required
	Algorithm string `json:"algorithm" yaml:"algorithm"`
}

type AuthRequest struct {
	AuthType   string `json:"auth_type" yaml:"auth_type"`
	Nonce      int    `json:"nonce" yaml:"nonce"`
	NonceCount int    `json:"nc" yaml:"nc"`
	Realm      string `json:"realm" yaml:"realm"`
	Algorithm  string `json:"algorithm" yaml:"algorithm"`
	Username   string `json:"username" yaml:"username"`
	Password   string `json:"password" yaml:"password"`
}

// Clone return copy
func (t *AuthRequest) Clone() *AuthRequest {
	c := &AuthRequest{}
	copier.Copy(&c, &t)
	return c
}

func (t *AuthRequest) ToAuthResponse() (*AuthResponse, error) {

	if t.NonceCount <= 0 {
		return nil, fmt.Errorf("attribute 'NonceCount' not valid")
	}

	if t.Realm == "" {
		return nil, fmt.Errorf("attribute 'Realm' empty")
	}

	if t.Algorithm == "" {
		return nil, fmt.Errorf("attribute 'Algorithm' empty")
	}

	if t.Username == "" {
		return nil, fmt.Errorf("attribute 'Username' empty")
	}

	if t.Password == "" {
		return nil, fmt.Errorf("attribute 'Password' empty")
	}

	cnonce := getCnonce()

	auth := &AuthResponse{
		Nonce:     fmt.Sprintf("%d", t.Nonce),
		Realm:     t.Realm,
		Username:  t.Username,
		Cnonce:    cnonce,
		Algorithm: t.Algorithm,
	}

	switch t.Algorithm {

	case "SHA-256":
		ha1 := getSHA256(t.Username + ":" + t.Realm + ":" + t.Password)
		// ha2 := getSHA256("dummy_method:dummy_uri")
		auth.Response = getSHA256(fmt.Sprintf("%s:%d:%v:%s:%s:%s", ha1, t.Nonce, t.NonceCount, cnonce, "auth", dummyHA2))

	default:
		return nil, fmt.Errorf("algorithm %s not supported", auth.Algorithm)

	}

	return auth, nil
}

type MessageHandlerFactory interface {
	NewHandle(string) MessageHandler
	IsAuthEnabled() bool
	Close()
}

type MessageHandler interface {
	Send(ctx context.Context, request *Request) ([]byte, error)
}

// Request generic request
type Request struct {
	Auth   *AuthResponse
	ID     *int        `json:"id,omitempty" yaml:"id,omitempty"`
	Method *string     `json:"method,omitempty" yaml:"method,omitempty"`
	Params interface{} `json:"params,omitempty" yaml:"params,omitempty"`
}

// Clone return copy
func (t *Request) Clone() *Request {
	c := &Request{}
	copier.Copy(&c, &t)
	return c
}

// Response generic response
type Response struct {
	ID    *int    `json:"id,omitempty" yaml:"id,omitempty"`
	Src   *string `json:"src,omitempty" yaml:"src,omitempty"`
	Error *Error  `json:"error,omitempty" yaml:"error,omitempty"`
}

// Clone return copy
func (t *Response) Clone() *Response {
	c := &Response{}
	copier.Copy(&c, &t)
	return c
}

// Error Shelly Error
type Error struct {
	Code    int    `json:"code,omitempty" yaml:"code,omitempty"`
	Message string `json:"message,omitempty" yaml:"message,omitempty"`
}

func (t *Error) Error() string {

	if t == nil {
		panic("error is nil")
	}

	m := errorCodeMap[t.Code]

	if m != "" {
		return fmt.Sprintf("status %d: err %s; %s", t.Code, t.Message, m)
	}

	return fmt.Sprintf("status %d: err %s", t.Code, t.Message)
}

type ErrorCode int

var getErrorCodeMap = func() map[int]string {
	return map[int]string{
		ErrorCodeInvalidArgument:    "parameters sent in the request do not match the ones specified by the method in the request",
		ErrorCodeDeadLineExceeded:   "request timeout",
		ErrorCodeNotFound:           "instance with specified ID not found",
		ErrorCodeResourceExhausted:  "resource has reached its limit. For example, when you try to create 21 schedule jobs on one Shelly device (the limit is 20)",
		ErrorCodeFailedPrecondition: "precondition for a requested action is not satisfied. For example, when you try to turn a switch on in a situation of overpower condition, or when a reboot has been scheduled and the device is shutting down",
		ErrorCodeUnAvailable:        "service is unavailable. The service can be internal - a sensor could be unreachable, or external. External services are - timezone information, firmware update or HTTP requests in Scripts.",
		ErrorCodeNotImplemented:     "method is not implemented on this device or caller is not authorized",
	}
}

var errorCodeMap = getErrorCodeMap()
